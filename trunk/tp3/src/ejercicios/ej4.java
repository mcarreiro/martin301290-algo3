package ejercicios;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

import ejercicios.Grafo.Vertice;

public class ej4 {

	//static Collection<Grafo.Vertice> grafoOriginal;
	
	public static Grafo MCD_LocalSearch(Grafo g){
		Ej3 ej3 = new Ej3();
		ArrayList<Vertice> greedySolution = ej3.MCD_Greedy(g); //Nodos dominados
		Hasta tuveQueAgregar > k
			ListaTupladeVertices ObtenerParesDeNodosOrdenadosPorFuncionF;
				si se peude hacer 2x1  
					tuveQueAGregar = 0;
					cambiar 2x1;//No hay que chequear que sea dominante porque el se puede ya te lo da, calcuar N(x,y) = N(z)
				si no
					i = random
					ArregloFunciones funcion(i); //MEDIO TRUCHO
						*agregar 1 nodo de los no dominantes
						*quitar un nodod en caso de poder
						*cambiar un nodo dominante por otro no dominante y que siga siendo dominante
					tuveQueAGregar++;		
	}
	
	
	
}
